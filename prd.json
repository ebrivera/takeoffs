{
  "project": "cantena-cost-engine",
  "branchName": "ralph/cost-engine-foundation",
  "description": "The cost estimation engine for Cantena — a standalone, well-tested Python library that takes a BuildingModel and produces a CostEstimate broken down by CSI division with confidence ranges. No UI, no VLM, no PDF processing — just the estimation logic, cost data, and domain types.",
  "userStories": [
    {
      "id": "US-001",
      "title": "Project scaffolding and tooling",
      "description": "As a developer, I want a properly structured Python project with linting, type checking, and testing configured so that every subsequent story has a quality foundation to build on.",
      "acceptanceCriteria": [
        "Directory structure: backend/cantena/ (source), backend/tests/ (tests), backend/pyproject.toml",
        "pyproject.toml configures: pytest, mypy (strict mode), ruff, pytest-cov",
        "Dependencies installed: pytest, pytest-cov, mypy, ruff, pydantic (for domain models)",
        "cantena/ has __init__.py, py.typed marker file",
        "A trivial test in tests/test_smoke.py that imports cantena and passes",
        "All quality gates pass: pytest, mypy --strict, ruff check",
        "A README.md in backend/ explaining the project structure and how to run tests",
        "Typecheck passes"
      ],
      "priority": 1,
      "passes": true,
      "notes": "Use Python 3.11+. Use pydantic v2 for domain models — it gives us runtime validation, JSON serialization, and schema generation for free. Do NOT add FastAPI or any web framework yet — this PRD is library-only. Keep dependencies minimal."
    },
    {
      "id": "US-002",
      "title": "Domain models: BuildingModel and related types",
      "description": "As a developer, I want well-typed domain models that represent the input to the cost engine (what the VLM will eventually extract from drawings) so that the rest of the system has a clear, validated contract to work with.",
      "acceptanceCriteria": [
        "cantena/models/building.py defines BuildingModel as a Pydantic BaseModel with fields: building_type (enum), building_use (str), gross_sf (float), stories (int), story_height_ft (float), structural_system (enum), exterior_wall_system (enum), mechanical_system (enum or None), electrical_service (enum or None), fire_protection (enum or None), location (Location model), complexity_scores (ComplexityScores model), special_conditions (list[str]), confidence (dict mapping field names to Confidence enum)",
        "Enums defined in cantena/models/enums.py: BuildingType (12+ values), StructuralSystem (5 values), ExteriorWall (7 values), MechanicalSystem (5 values), ElectricalService (3 values), FireProtection (3 values), Confidence (3 values) — all with exact values specified in PRD",
        "Location model in cantena/models/building.py with city (str), state (str), zip_code (str, optional)",
        "ComplexityScores model with validation that each score is 1-5",
        "All models export cleanly from cantena.models",
        "Tests in tests/test_models.py: valid construction, validation errors for bad data (negative SF, stories < 1, complexity out of range), JSON round-trip serialization, default values work correctly",
        "mypy --strict passes on all model files",
        "Typecheck passes"
      ],
      "priority": 2,
      "passes": true,
      "notes": "These enums and models represent the RSMeans square foot estimator input parameters mapped to our domain. BuildingType values come from RSMeans' 100+ building type models — we start with the most common 12. The confidence dict lets the VLM signal which fields it's sure about vs guessing. Keep models in a models/ subpackage."
    },
    {
      "id": "US-003",
      "title": "Domain models: CostEstimate and budget output types",
      "description": "As a developer, I want well-typed output models that represent a conceptual cost estimate so that consumers (UI, PDF export, API) have a clear, structured contract.",
      "acceptanceCriteria": [
        "cantena/models/estimate.py defines CostEstimate as a Pydantic BaseModel with fields: project_name (str), building_summary (BuildingSummary), total_cost (CostRange), cost_per_sf (CostRange), breakdown (list[DivisionCost]), assumptions (list[Assumption]), generated_at (datetime), location_factor (float), metadata (EstimateMetadata)",
        "DivisionCost model with: csi_division (str), division_name (str), cost (CostRange), percent_of_total (float), source (str)",
        "CostRange model with: low (float), expected (float), high (float) and validator that low <= expected <= high",
        "Assumption model with: parameter (str), assumed_value (str), reasoning (str), confidence (Confidence enum)",
        "BuildingSummary model with: building_type (str), gross_sf (float), stories (int), structural_system (str), exterior_wall (str), location (str)",
        "EstimateMetadata model with: engine_version (str), cost_data_version (str), estimation_method (str, default 'square_foot_conceptual')",
        "Tests in tests/test_models_estimate.py: valid construction, CostRange validation, JSON serialization, a helper that builds a realistic example estimate",
        "mypy --strict passes",
        "Typecheck passes"
      ],
      "priority": 3,
      "passes": true,
      "notes": "CostRange is a key concept — we NEVER output a single number. Every cost is low/expected/high. This is methodologically correct (RSMeans ROM estimates are ±25%) and builds trust with PMs. The Assumption model makes the AI's reasoning transparent — every number traces back to a source."
    },
    {
      "id": "US-004",
      "title": "Cost data layer: schema and seed data for building types",
      "description": "As a developer, I want a cost data layer with seed data for common building types so that the cost engine can look up square-foot costs by building type, structural system, and wall system.",
      "acceptanceCriteria": [
        "cantena/data/ directory with cost data stored as Pydantic models (in-memory, no database)",
        "cantena/data/building_costs.py defines SquareFootCostEntry with: building_type, structural_system, exterior_wall, stories_range (tuple[int,int]), cost_per_sf (CostRange), year (int), notes (str)",
        "cantena/data/seed.py contains at least 15 SquareFootCostEntry records covering realistic combinations with realistic 2025 national average costs",
        "cantena/data/csi_divisions.py defines standard CSI divisions (01-14, 21-28, 31-33) with typical percentage breakdowns by building type",
        "cantena/data/city_cost_index.py with at least 30 city cost indexes (NYC=1.30, SF=1.35, Houston=0.88, etc., national average=1.00)",
        "cantena/data/repository.py defines CostDataRepository with methods: get_sf_cost, get_best_match_sf_cost (fuzzy match with fallbacks), get_division_breakdown, get_city_cost_index",
        "Tests in tests/test_cost_data.py: exact match lookup, fuzzy match fallback, city index for known/unknown cities, division percentages sum to ~100%, no duplicate seed entries",
        "mypy --strict passes",
        "Typecheck passes"
      ],
      "priority": 4,
      "passes": true,
      "notes": "In-memory data intentionally — PostgreSQL comes later. CostDataRepository abstraction means we can swap backend without changing the engine. Fuzzy matching in get_best_match_sf_cost is critical — the VLM might extract combinations we don't have exact matches for. Cost data from publicly available RSMeans square foot cost book data and ENR construction cost indexes."
    },
    {
      "id": "US-005",
      "title": "Cost engine: BuildingModel to CostEstimate",
      "description": "As a developer, I want the core estimation engine that takes a BuildingModel and produces a CostEstimate so that I have the complete domain logic working end-to-end before adding any VLM or UI layer.",
      "acceptanceCriteria": [
        "cantena/engine.py defines CostEngine class that takes a CostDataRepository in its constructor",
        "CostEngine.estimate(building, project_name) method implements the full pipeline: lookup base $/SF, apply location factor, apply complexity multipliers (1=0.85, 2=0.95, 3=1.00, 4=1.10, 5=1.25 with weighted average), calculate total, generate CostRange (low=expected*0.80, high=expected*1.25), break down into CSI divisions, collect assumptions",
        "Complexity multiplier weights: structural=0.3, MEP=0.3, finishes=0.25, site=0.15",
        "Each assumption is documented: fuzzy match usage, low confidence fields noted",
        "Raises descriptive ValueError if no cost data match found at all",
        "Tests in tests/test_engine.py: happy path wood-frame apartment ($180-250/SF range), location factor (NYC vs Houston ~40% difference), complexity multipliers (all 5s ~25% higher than all 3s), division breakdown sums to total, assumptions populated on fuzzy match, ValueError for unknown type, low confidence produces assumptions",
        "Tests use realistic values — 45K SF office should estimate $9M-$16M range",
        "mypy --strict passes",
        "Typecheck passes"
      ],
      "priority": 5,
      "passes": true,
      "notes": "This is THE core story. Complexity multiplier approach is how experienced estimators adjust conceptual estimates. 0.80-1.25 range matches RSMeans' ±20-25% accuracy for square foot estimates."
    },
    {
      "id": "US-006",
      "title": "Convenience factory and public API surface",
      "description": "As a developer integrating the cost engine (from a FastAPI route, a CLI, or a test), I want a simple, well-documented API surface so that I don't need to understand the internal wiring to use it.",
      "acceptanceCriteria": [
        "cantena/__init__.py exports: CostEngine, BuildingModel, CostEstimate, CostRange, create_default_engine, and all enum types",
        "cantena/factory.py defines create_default_engine() -> CostEngine that wires up CostDataRepository with seed data",
        "Usage is: from cantena import create_default_engine, BuildingModel; engine = create_default_engine(); estimate = engine.estimate(building)",
        "cantena/engine.py has module-level docstring explaining estimation methodology",
        "CostEngine.estimate() has complete docstring with Args, Returns, Raises, Example",
        "Tests in tests/test_public_api.py: import via public API, create_default_engine works, full round-trip BuildingModel -> estimate -> JSON -> deserialize, JSON output is valid consumable structure",
        "mypy --strict passes",
        "Typecheck passes"
      ],
      "priority": 6,
      "passes": true,
      "notes": "This is about developer ergonomics. When PRD 2 adds FastAPI and the VLM pipeline, the integration point should be dead simple. JSON round-trip test is important because the frontend will consume this over HTTP."
    },
    {
      "id": "US-007",
      "title": "End-to-end scenario tests with realistic buildings",
      "description": "As a developer, I want end-to-end scenario tests with realistic construction projects so that I have confidence the engine produces sensible estimates before connecting it to a VLM or UI.",
      "acceptanceCriteria": [
        "tests/test_scenarios.py contains at least 4 realistic scenario tests",
        "Scenario 1 - Suburban Apartment: 3-story wood-frame, 36K SF, brick veneer, Baltimore MD, standard complexity — total $5.5M-$10M, cost/SF $150-$280",
        "Scenario 2 - Urban Office: 8-story steel frame, 120K SF, curtain wall, New York NY, high complexity (4,4,3,4) — total $30M-$55M, cost/SF $250-$450",
        "Scenario 3 - Distribution Warehouse: 1-story steel frame, 80K SF, metal panel, Houston TX, low complexity (2,2,1,2) — total $6M-$14M, cost/SF $75-$175",
        "Scenario 4 - Elementary School: 2-story masonry, 45K SF, brick veneer, Denver CO, standard complexity — total $9M-$18M, cost/SF $200-$400",
        "Each scenario asserts: estimate not None, total cost range populated, cost/SF in expected range, at least 5 CSI divisions, division costs sum to total, assumptions not empty, location factor applied",
        "Helper function or fixture provides each scenario as a BuildingModel for reuse",
        "All quality gates pass",
        "Tests pass",
        "Typecheck passes"
      ],
      "priority": 7,
      "passes": false,
      "notes": "Ranges are intentionally wide because conceptual estimates ARE wide. The point is we don't produce obviously wrong numbers. These scenarios will also serve as integration test data when we add the VLM. Cost ranges from RSMeans 2025 data and real project experience."
    },
    {
      "id": "US-008",
      "title": "JSON output formatting and estimate summary helpers",
      "description": "As a developer building the future frontend, I want helper methods that produce well-formatted summary data from a CostEstimate so that I don't have to reimplement formatting logic in the UI layer.",
      "acceptanceCriteria": [
        "cantena/formatting.py defines format_currency(amount) -> str: '$X,XXX,XXX' (no cents over $10K, with cents for smaller)",
        "cantena/formatting.py defines format_cost_range(cr) -> str: '$X.XM - $X.XM' for millions, '$XXX,XXX - $XXX,XXX' for smaller",
        "cantena/formatting.py defines format_sf_cost(cr) -> str: '$XXX - $XXX / SF'",
        "CostEstimate gets to_summary_dict() -> dict with: project_name, building_type, gross_sf_formatted, total_cost_formatted, total_cost_range_formatted, cost_per_sf_formatted, cost_per_sf_range_formatted, location, location_factor, num_divisions, top_cost_drivers (top 3 by cost), num_assumptions, generated_at_formatted",
        "CostEstimate gets to_export_dict() -> dict with full detailed data for Excel/PDF export",
        "Tests in tests/test_formatting.py: currency formatting edge cases, cost range formatting, summary dict has all keys, export dict has all keys, formatting consistency",
        "mypy --strict passes",
        "Typecheck passes"
      ],
      "priority": 8,
      "passes": false,
      "notes": "Construction PMs care deeply about number presentation. '$12.4M' is how they talk, not '$12,437,892.34'. Summary dict is designed to be directly consumable by a React frontend. Export dict feeds into PDF and Excel generation in PRD 2."
    }
  ]
}
