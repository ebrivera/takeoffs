{
  "project": "cantena-geometry-engine",
  "branchName": "ralph/geometry-engine",
  "description": "Geometry extraction and measurement engine that pulls vector graphics from CAD-exported PDF construction drawings, calibrates to real-world scale, and computes actual areas/perimeters/wall lengths. Replaces VLM guessing with computed measurements from drawing geometry.",
  "userStories": [
    {
      "id": "US-301",
      "title": "Vector path extraction from PDF pages",
      "description": "As a developer, I want to extract all vector drawing paths (lines, rectangles, curves) from a PDF page as structured coordinate data so that I can analyze the geometry of construction drawings programmatically rather than relying solely on pixel-based image analysis.",
      "acceptanceCriteria": [
        "`cantena/geometry/extractor.py` defines `VectorExtractor` class",
        "`VectorExtractor.extract(page: fitz.Page) -> DrawingData` uses PyMuPDF `page.get_drawings()` to extract all vector paths",
        "`DrawingData` model contains: paths (list[VectorPath]), page_width_pts (float), page_height_pts (float), page_size_inches (tuple[float, float] computed from points at 72 pts/inch)",
        "`VectorPath` model contains: path_type (line | rect | curve | polyline), points (list[Point2D]), stroke_color (tuple[float, float, float] | None), fill_color (tuple[float, float, float] | None), line_width (float), bounding_rect (BoundingRect with x, y, width, height in PDF points)",
        "`Point2D` is a simple model with x (float) and y (float) in PDF coordinate space (points)",
        "Lines extracted as pairs of points, rectangles as 4 corners, curves as control points, polylines as sequences of connected points",
        "`VectorExtractor.filter_by_region(data: DrawingData, region: BoundingRect) -> DrawingData` returns only paths within or intersecting the given region",
        "`VectorExtractor.get_stats(data: DrawingData) -> DrawingStats` returns path_count, line_count, rect_count, curve_count, total_line_length_pts, bounding_box of all geometry",
        "Test: Create test PDF with known geometry using PyMuPDF Shape (draw rectangle and two lines), extract them back, verify coordinates match",
        "Test: filter_by_region excludes paths outside region",
        "Test: Stats computed correctly",
        "Test: Empty page returns empty DrawingData",
        "Test: Page with only text returns empty paths list",
        "Tests pass",
        "Typecheck passes"
      ],
      "priority": 1,
      "passes": true,
      "notes": "Most construction PDFs are exported from CAD software and contain vector geometry. PyMuPDF get_drawings() returns these as structured dictionaries. Coordinate system is PDF points (72 points = 1 inch). The filter_by_region method is important for excluding title block border and annotation areas."
    },
    {
      "id": "US-302",
      "title": "Scale detection: parse title block and dimension annotations",
      "description": "As a developer, I want to automatically detect the drawing scale from title block text and dimension annotation strings so that I can convert PDF coordinate measurements into real-world feet and inches.",
      "acceptanceCriteria": [
        "`cantena/geometry/scale.py` defines `ScaleDetector` class",
        "`ScaleDetector.detect_from_text(page_text: str) -> ScaleResult | None` parses common architectural scale notations: 1/8\"=1'-0\", 1/4\"=1'-0\", 1:100, 1:50, SCALE: 1/8\"=1'0\", 3/16\"=1'-0\", 1\"=10'-0\" plus variants with inconsistent spacing and punctuation",
        "`ScaleResult` model: drawing_units (float, inches on paper), real_units (float, inches in real world), scale_factor (float, real_units / drawing_units e.g. 96.0 for 1/8\"=1'-0\"), notation (str, original parsed text), confidence (HIGH if exact pattern match, MEDIUM if fuzzy)",
        "`ScaleDetector.detect_from_dimensions(paths: list[VectorPath], texts: list[TextBlock]) -> ScaleResult | None` cross-references dimension lines with numeric values in nearby text blocks to infer scale",
        "`TextBlock` model: text (str), position (Point2D center), bounding_rect (BoundingRect)",
        "`ScaleDetector.extract_text_blocks(page: fitz.Page) -> list[TextBlock]` uses PyMuPDF text extraction to get all text with positions",
        "Helper `parse_dimension_string(text: str) -> float | None` parses: 24'-6\", 24'6\", 24.5', 10'-0\", 150'-0\" into inches (294.0 for 24'-6\")",
        "Test: Parse common scale notations (1/8\"=1'-0\" -> factor 96, 1/4\"=1'-0\" -> factor 48, 3/16\"=1'-0\" -> factor 64, 1\"=10'-0\" -> factor 120)",
        "Test: Parse dimension strings (24'-6\" -> 294, 10'-0\" -> 120)",
        "Test: Handle messy text with extra spaces, different quote styles",
        "Test: Return None for unparseable text",
        "Test: detect_from_text finds scale in block of title block text containing other content",
        "Tests pass",
        "Typecheck passes"
      ],
      "priority": 2,
      "passes": true,
      "notes": "Scale detection is the critical step for turning PDF geometry into real-world measurements. Architectural scales are standard: 1/8\"=1'-0\" most common for floor plans (scale factor = 96). Title block almost always states scale explicitly. The dimension-based inference is a fallback — calibrates from actual annotated dimensions."
    },
    {
      "id": "US-303",
      "title": "Wall detection and room boundary identification",
      "description": "As a developer, I want to identify wall lines in the vector geometry so that I can detect room boundaries and compute floor areas from the actual drawing geometry.",
      "acceptanceCriteria": [
        "`cantena/geometry/walls.py` defines `WallDetector` class",
        "`WallDetector.detect(data: DrawingData) -> WallAnalysis` identifies probable wall segments from vector paths",
        "Wall detection heuristics: (a) lines with heavier stroke width (0.5mm+ vs 0.13mm), (b) lines strictly horizontal or vertical (+/- 2 degrees), (c) pairs of parallel lines close together (wall thickness 4-12 inches at scale), (d) lines with wall-typical colors (black, dark gray)",
        "`WallSegment` model: start (Point2D), end (Point2D), thickness_pts (float | None), orientation (HORIZONTAL | VERTICAL | ANGLED), length_pts (float)",
        "`WallAnalysis` model: segments (list[WallSegment]), total_wall_length_pts (float), detected_wall_thickness_pts (float | None median), outer_boundary (list[Point2D] | None)",
        "`WallDetector.compute_enclosed_area_pts(segments: list[WallSegment]) -> float | None` computes gross floor area using Shapely Polygon from outer boundary points",
        "Shapely library added to dependencies",
        "Test: Create test PDF with thick lines (walls) and thin lines (annotations), verify thick lines detected",
        "Test: Two parallel lines 6pts apart detected as wall pair",
        "Test: Compute enclosed area of simple rectangular plan",
        "Test: Filter out thin lines correctly",
        "Test: No walls detected returns empty analysis not error",
        "Tests pass",
        "Typecheck passes"
      ],
      "priority": 3,
      "passes": true,
      "notes": "Depends on US-301 DrawingData model and US-302 TextBlock model. Wall detection from vector data uses lineweight conventions: architects use heavy lineweight for walls (0.50mm or 0.70mm) and light for dimensions (0.13mm). Shapely handles polygon operations and area calculation."
    },
    {
      "id": "US-304",
      "title": "Scaled measurement service: PDF geometry to real-world dimensions",
      "description": "As a developer, I want a service that combines vector extraction + scale detection + wall analysis to produce real-world measurements (square feet, linear feet of wall, building perimeter) from a PDF page.",
      "acceptanceCriteria": [
        "`cantena/geometry/measurement.py` defines `MeasurementService` class taking `VectorExtractor`, `ScaleDetector`, and `WallDetector`",
        "`MeasurementService.measure(page: fitz.Page) -> PageMeasurements` runs full pipeline on single page",
        "`PageMeasurements` model: scale (ScaleResult | None), gross_area_sf (float | None), building_perimeter_lf (float | None), total_wall_length_lf (float | None), wall_count (int), confidence (MeasurementConfidence enum: HIGH/MEDIUM/LOW/NONE), raw_data (DrawingData)",
        "Conversion functions: `pts_to_real_sf(pts_squared: float, scale: ScaleResult) -> float` and `pts_to_real_lf(pts: float, scale: ScaleResult) -> float`",
        "Area formula: area_sf = area_pts * (1/72)^2 * scale_factor^2 / 144; Length formula: length_lf = length_pts * (1/72) * scale_factor / 12",
        "Graceful fallbacks: No vector data -> NONE; Vector data no scale -> estimate from page size -> LOW; Walls detected no closed boundary -> convex hull area -> MEDIUM",
        "Test: PDF at known scale with 100'x50' rectangle at 1/8\"=1'-0\" (900pts x 450pts on paper), verify area ~5000 SF +/-5%",
        "Test: Verify perimeter ~300 LF +/-5%",
        "Test: Conversion functions with known values",
        "Test: No vector data returns NONE confidence",
        "Test: Missing scale returns LOW confidence",
        "Tests pass",
        "Typecheck passes"
      ],
      "priority": 4,
      "passes": true,
      "notes": "Depends on US-301, US-302, US-303. This is where geometry becomes measurements. Conversion math: PDF coordinates in points (72/inch), scale factor converts paper inches to real inches. The fallback chain ensures we always try to give something rather than failing."
    },
    {
      "id": "US-305",
      "title": "Hybrid analysis: merge geometry measurements with VLM semantic analysis",
      "description": "As a developer, I want to merge geometry-computed measurements with VLM-extracted semantic information so the cost engine gets accurate areas from geometry and building type identification from the VLM.",
      "acceptanceCriteria": [
        "`cantena/services/hybrid_analyzer.py` defines `HybridAnalyzer` taking `MeasurementService` and `VlmAnalyzer`",
        "`HybridAnalyzer.analyze(page: fitz.Page, image_path: Path, context: AnalysisContext | None = None) -> HybridAnalysisResult` runs both geometry and VLM on same page",
        "`HybridAnalysisResult` model: building_model (BuildingModel merged), geometry_measurements (PageMeasurements), vlm_result (VlmAnalysisResult), merge_decisions (list[MergeDecision])",
        "`MergeDecision` model: field_name (str), source (GEOMETRY | VLM | USER_OVERRIDE), value (str), reasoning (str), confidence (Confidence)",
        "Merge logic: gross_sf uses geometry if HIGH/MEDIUM confidence else VLM; stories/building_type/structural_system/exterior_wall/mechanical_system always VLM; story_height VLM; location from context; complexity_scores VLM; special_conditions merges both",
        "Merged BuildingModel.confidence dict reflects actual source",
        "Test: Geometry HIGH 45000 SF + VLM 42000 SF -> merged uses 45000",
        "Test: Geometry NONE -> falls back to VLM",
        "Test: Building type always from VLM",
        "Test: Merge decisions documented",
        "Test: Geometry anomalies added to special_conditions",
        "Tests pass",
        "Typecheck passes"
      ],
      "priority": 5,
      "passes": true,
      "notes": "Depends on US-304 and existing VlmAnalyzer. Geometry gives precise measurements, VLM gives semantic interpretation. MergeDecision log is crucial for trust — PM sees source and confidence for each field."
    },
    {
      "id": "US-306",
      "title": "Update pipeline to use hybrid analysis",
      "description": "As a developer, I want the AnalysisPipeline to use HybridAnalyzer when vector geometry is available so the /api/analyze endpoint automatically gets more accurate measurements without frontend changes.",
      "acceptanceCriteria": [
        "AnalysisPipeline updated to optionally use `HybridAnalyzer`",
        "Pipeline logic: (1) Process PDF to images, (2) Extract vector data using VectorExtractor, (3) If vector data has >50 paths use HybridAnalyzer else VLM-only, (4) Return enhanced PipelineResult",
        "`PipelineResult` extended with: geometry_available (bool), measurement_confidence (MeasurementConfidence), merge_decisions (list[MergeDecision] | None)",
        "`/api/analyze` response includes geometry_available and measurement_confidence",
        "Backward compatible: without HybridAnalyzer configured, falls back to VLM-only",
        "Test: Vector-rich PDF uses HybridAnalyzer",
        "Test: Scanned PDF falls back to VLM-only",
        "Test: PipelineResult includes geometry fields",
        "Test: Backward compatible without HybridAnalyzer",
        "Tests pass",
        "Typecheck passes"
      ],
      "priority": 6,
      "passes": true,
      "notes": "Depends on US-305. Drop-in upgrade. Frontend unchanged, but measurements are computed from actual geometry when available. The >50 paths threshold distinguishes real CAD geometry from border/annotation marks."
    },
    {
      "id": "US-307",
      "title": "Geometry debug visualization endpoint",
      "description": "As a developer testing geometry detection, I want a debug endpoint that overlays detected walls and measurements on the original drawing so I can visually verify accuracy.",
      "acceptanceCriteria": [
        "`GET /api/debug/geometry` accepts PDF upload, returns PNG with overlay",
        "Overlay shows: detected walls in red, outer boundary in blue, area text, scale notation, confidence badge",
        "Uses PyMuPDF to render base image, Pillow for overlays",
        "Also returns JSON: raw measurements, wall segments, scale, stats",
        "Test: Returns 200 with PNG for valid PDF",
        "Test: JSON includes measurements",
        "Test: Returns 400 for non-PDF",
        "Tests pass",
        "Typecheck passes"
      ],
      "priority": 7,
      "passes": true,
      "notes": "Depends on US-304. Essential for tuning wall detection heuristics. Upload a real construction PDF, see what geometry engine detected overlaid on the drawing. Also becomes a powerful demo tool. Pillow added to dependencies."
    }
  ]
}
