{
  "project": "cantena-geometry-llm-enhanced",
  "branchName": "ralph/geometry-llm-enhanced",
  "description": "Enhances the geometry engine with polygonize-based room polygon reconstruction, endpoint snapping, room label matching, LLM-assisted geometry interpretation, and scale verification safety rail.",
  "userStories": [
    {
      "id": "US-371",
      "title": "Endpoint snapping: close near-miss gaps in wall segments",
      "description": "As a developer, I want wall segment endpoints that are within a small tolerance of each other to be snapped together so that Shapely polygonize() can form closed room polygons from wall lines that have tiny CAD-export gaps.",
      "acceptanceCriteria": [
        "cantena/geometry/snap.py defines snap_endpoints(segments: list[WallSegment], tolerance_pts: float = 3.0) -> list[WallSegment]",
        "Function collects all unique endpoints, finds clusters within tolerance_pts, replaces each cluster with its centroid, returns new WallSegment objects with snapped endpoints",
        "Clustering uses simple O(n^2) pairwise distance check; document KDTree upgrade path if needed",
        "Helper snap_to_grid(point: Point2D, grid_size_pts: float = 1.0) -> Point2D rounds coordinates to nearest grid point",
        "After snapping, duplicate segments (same start/end after snapping) are removed",
        "Tests in tests/test_snap.py: endpoints 2pts apart snap together; endpoints 5pts apart do NOT snap; duplicate segments removed; grid snapping rounds correctly; empty input returns empty; exactly matching endpoints unchanged",
        "mypy --strict passes",
        "Typecheck passes"
      ],
      "priority": 1,
      "passes": true,
      "notes": "polygonize() needs exact endpoint equality. Snapping within a small tolerance fixes CAD-export floating-point gaps without meaningfully distorting geometry."
    },
    {
      "id": "US-372",
      "title": "Room polygon reconstruction via Shapely polygonize",
      "description": "As a developer, I want to reconstruct enclosed room polygons from wall segments using Shapely's polygonize() so that I can compute individual room areas instead of relying on convex hull.",
      "acceptanceCriteria": [
        "cantena/geometry/rooms.py defines RoomDetector class",
        "RoomDetector.detect_rooms(segments, scale) snaps endpoints (US-371), extends wall segments slightly at endpoints (by 1pt), converts to Shapely LineStrings, unions linework with unary_union, calls polygonize(), filters tiny polygons (<100 sq pts) and page boundary polygons (>80% of page area), returns RoomAnalysis",
        "RoomAnalysis model (frozen dataclass): rooms list, total_area_pts, total_area_sf (if scale), room_count, outer_boundary_polygon, polygonize_success",
        "DetectedRoom model (frozen dataclass): polygon_pts, area_pts, area_sf, perimeter_pts, perimeter_lf, centroid, label, room_index",
        "If polygonize() produces 0 rooms, fall back to convex hull; set polygonize_success=False",
        "Tests in tests/test_rooms.py: rectangle -> 1 room with correct area; two adjacent rooms -> 2 polygons; small gaps (2pts) snapped -> still produces rooms; non-closing segments -> fallback hull; tiny artifacts filtered; area converts to SF when scale provided",
        "mypy --strict passes",
        "Typecheck passes"
      ],
      "priority": 2,
      "passes": true,
      "notes": "This is the main accuracy upgrade vs convex hull, especially on drawings with porches / recesses / dead space."
    },
    {
      "id": "US-373",
      "title": "Room label matching: associate text labels with detected room polygons",
      "description": "As a developer, I want to associate room name labels (text blocks like 'LIVING ROOM') with detected room polygons so each room has a name without needing the LLM.",
      "acceptanceCriteria": [
        "cantena/geometry/rooms.py extended with RoomDetector.label_rooms(rooms: RoomAnalysis, text_blocks: list[TextBlock]) -> RoomAnalysis",
        "Match text blocks against curated list of common room names (case-insensitive): LIVING ROOM, KITCHEN, DINING, BEDROOM, BATHROOM, RESTROOM, WC, UTILITY, LAUNDRY, CORRIDOR, HALLWAY, CLOSET, STORAGE, OFFICE, CONFERENCE, LOBBY, ENTRY, FOYER, GARAGE, PORCH, DECK, MECHANICAL, etc.",
        "For matched labels: find polygon containing text position (Point.within(Polygon)); if none contains, assign to nearest centroid within 50pts",
        "Handle edge cases: multiple labels in one room (use first/most prominent); label outside all rooms (assign nearest); duplicate labels (append index: BEDROOM 1, BEDROOM 2)",
        "Tests in tests/test_room_labels.py: label inside polygon assigns correctly; label outside assigns to nearest; non-room text ignored; unlabeled rooms remain None; duplicate names get indexed",
        "mypy --strict passes",
        "Typecheck passes"
      ],
      "priority": 3,
      "passes": true,
      "notes": "This is 'no-AI room naming' using spatial containment + a curated vocabulary."
    },
    {
      "id": "US-374",
      "title": "LLM-assisted geometry interpretation service",
      "description": "As a developer, I want an LLM service that takes extracted geometry data (rooms, measurements, text) and the PDF page image, and uses Claude to produce richer semantic analysis and a structured SpaceProgram.",
      "acceptanceCriteria": [
        "cantena/services/llm_geometry_interpreter.py defines LlmGeometryInterpreter taking an API key in constructor",
        "LlmGeometryInterpreter.interpret(geometry_summary: GeometrySummary, page_image_path: Path | None = None) -> LlmInterpretation sends structured data to Claude and parses structured JSON output",
        "GeometrySummary (frozen dataclass): scale_notation, scale_factor, total_area_sf, rooms (list[RoomSummary]), all_text_blocks, wall_count, measurement_confidence",
        "RoomSummary model: room_index, label, area_sf, perimeter_lf",
        "LlmInterpretation model: building_type, structural_system, rooms (list[LlmRoomInterpretation]), special_conditions, measurement_flags, confidence_notes",
        "LlmRoomInterpretation model: room_index, confirmed_label, room_type_enum, notes",
        "If page_image_path provided, send as vision input; timeout 30s; if API call fails, return default LlmInterpretation with UNKNOWN fields",
        "Uses Anthropic SDK directly (not VlmAnalyzer)",
        "Tests in tests/test_llm_geometry_interpreter.py: mocked API JSON parsed correctly; malformed response -> default fallback; timeout -> default fallback; GeometrySummary serializes correctly",
        "mypy --strict passes",
        "Typecheck passes"
      ],
      "priority": 4,
      "passes": true,
      "notes": "LLM validates/enriches computed geometry rather than guessing measurements from pixels."
    },
    {
      "id": "US-378",
      "title": "Scale verification safety rail via LLM (linchpin protection)",
      "description": "As a developer, I want scale detection to be verified (and optionally recovered) via an LLM-assisted check so that a brittle title-block parse or unreliable dimension inference cannot silently produce massively wrong areas (scale^2 error).",
      "acceptanceCriteria": [
        "cantena/geometry/scale_verify.py defines ScaleVerifier with verify_or_recover_scale(page, detected, text_blocks) -> ScaleVerificationResult",
        "ScaleVerificationResult model: scale (ScaleResult | None), verification_source (Literal['DETERMINISTIC', 'LLM_CONFIRMED', 'LLM_RECOVERED', 'UNVERIFIED']), warnings (list[str]), llm_raw_notation (str | None)",
        "LLM inputs are narrow: title-block region text, candidate scale strings, optionally a crop image of the title block",
        "LLM request asks for strict JSON: notation, paper_inches, real_inches, scale_factor, confidence (HIGH|MEDIUM|LOW)",
        "Decision logic: HIGH detected + LLM agrees ±5% -> LLM_CONFIRMED; LOW/MEDIUM/None detected + LLM HIGH/MEDIUM -> LLM_RECOVERED; LLM disagrees >10% -> keep detected with warning; dimension-based inference treated as unreliable unless corroborated",
        "If API key missing or LLM fails/timeouts/429: return UNVERIFIED and proceed with best deterministic scale",
        "Unit tests in tests/test_scale_verify.py (mocked API): deterministic HIGH + LLM agrees -> confirmed; deterministic None + LLM recovers -> recovered; disagreement emits warning; timeout/429 returns UNVERIFIED",
        "Opt-in integration test in tests/integration/test_first_floor_scale_llm.py: skip if ANTHROPIC_API_KEY missing; assert LLM-verifier returns ~48.0 (±2) for first-floor.pdf",
        "mypy --strict passes",
        "Typecheck passes"
      ],
      "priority": 5,
      "passes": true,
      "notes": "This makes scale robust without 'AI-everything.' The LLM is a guardrail and recovery tool for the one place where being wrong explodes downstream."
    },
    {
      "id": "US-375",
      "title": "Update MeasurementService to use room-based area computation",
      "description": "As a developer, I want MeasurementService to use polygonize-based RoomDetector for area computation and optionally run LLM enrichment so PageMeasurements includes per-room data and improved total area.",
      "acceptanceCriteria": [
        "MeasurementService (cantena/geometry/measurement.py) updated: measure() uses RoomDetector.detect_rooms() for area computation instead of (or in addition to) convex hull",
        "PageMeasurements extended: rooms (list[DetectedRoom] | None), room_count, polygonize_success, llm_interpretation (LlmInterpretation | None), scale_verification (ScaleVerificationResult | None)",
        "MeasurementService constructor takes optional llm_interpreter: LlmGeometryInterpreter | None and optional scale_verifier: ScaleVerifier | None",
        "Area computation priority: 1) sum polygonized room areas (HIGH), 2) convex hull (MEDIUM), 3) page-size estimate (LOW)",
        "Confidence reflects which area method + whether scale was verified/confirmed",
        "Backward compatible: existing tests still pass; room fields additive",
        "Tests in tests/test_measurement_rooms.py: rooms included when polygonize works; polygonized total closer than convex hull on synthetic examples; fallback to convex hull when polygonize fails; room_count + polygonize_success set correctly; without LLM interpreter llm_interpretation=None; with ScaleVerifier mocked scale_verification is populated",
        "mypy --strict passes",
        "Typecheck passes"
      ],
      "priority": 6,
      "passes": true,
      "notes": "The core measurement improvement is room-sum area. Scale verification feeds into confidence and reduces 'silent wrong' outcomes."
    },
    {
      "id": "US-376",
      "title": "Real API integration tests on first-floor.pdf",
      "description": "As a developer, I want integration tests that run the enhanced pipeline (geometry + room detection + LLM interpretation) on first-floor.pdf using real API calls, so I can validate the end-to-end system beyond mocks.",
      "acceptanceCriteria": [
        "tests/integration/test_first_floor_llm.py contains real API tests (NOT mocks); mark tests with @pytest.mark.llm; skip if ANTHROPIC_API_KEY missing",
        "Assert scale_verification.verification_source != 'UNVERIFIED' when ANTHROPIC_API_KEY is set",
        "test_llm_room_interpretation: run pipeline, send to LlmGeometryInterpreter with real API; assert non-default interpretation, building_type is residential, structural_system mentions wood frame or similar, >=3 rooms have confirmed labels, special_conditions mentions at least one of woodstove/chimney/hardwood/brick",
        "test_llm_with_image: also send rendered page image; assert response returned and is equal/better in richness",
        "test_full_pipeline_accuracy: total area from polygonized rooms in [400, 600] SF (~512 expected); >=4 named rooms; scale factor ~48 ±5; LLM identifies residential",
        "test_room_area_improvement_over_convex_hull: assert polygonize total is closer to 512 than convex hull total",
        "test_measurement_report_with_rooms: generate test_results/first-floor-enhanced-report.md with per-room breakdown + LLM summary",
        "Rate limits: if 429, pytest.skip rather than fail",
        "Typecheck passes"
      ],
      "priority": 7,
      "passes": true,
      "notes": "The definitive proof: polygonize improves accuracy on a real plan, and the LLM enriches without being required for measurement."
    },
    {
      "id": "US-377",
      "title": "Enhanced debug visualization with room polygons and labels",
      "description": "As a developer, I want the debug visualization endpoint to show detected room polygons with labels and areas overlaid on the drawing.",
      "acceptanceCriteria": [
        "POST /api/debug/geometry updated: overlay includes each room polygon semi-transparent fill (different per room), room label centered, room area (SF) below label, unlabeled rooms shown in gray with '?' + area",
        "JSON response extended: rooms[] with room_index, label, area_sf, perimeter_lf, polygon vertices, centroid coords",
        "If LLM interpretation available, include llm_interpretation in JSON",
        "Backward compatible: if no rooms detected, keep existing wall overlay",
        "Tests in tests/test_debug_rooms.py: room-detectable PDF returns rooms in JSON; PNG overlay modifies pixels in room areas; without rooms existing wall overlay works",
        "mypy --strict passes",
        "Typecheck passes"
      ],
      "priority": 8,
      "passes": false,
      "notes": "This becomes the best tuning + demo artifact: 'here is what we detected' directly on the drawing."
    }
  ]
}
