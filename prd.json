{
  "project": "cantena-enhanced-cost-intelligence",
  "branchName": "ralph/enhanced-cost-intelligence",
  "description": "Upgrades the cost engine from building-type-level lookup to assembly-level estimation using room-type awareness and geometry-detected room polygons for granular per-room cost estimates.",
  "userStories": [
    {
      "id": "US-401",
      "title": "Room-type cost differentiation data",
      "description": "As a developer, I want cost data that differentiates between room types within a building (lobby vs. open office vs. kitchen vs. bathroom vs. corridor) so that the estimate reflects actual cost variation across different spaces rather than applying a single $/SF rate to the whole building.",
      "acceptanceCriteria": [
        "`RoomType` StrEnum added to `cantena/models/enums.py` with values: LIVING_ROOM, KITCHEN, DINING, BEDROOM, BATHROOM, RESTROOM, WC, UTILITY, LAUNDRY, CLOSET, PORCH, LOBBY, OPEN_OFFICE, PRIVATE_OFFICE, CONFERENCE, CORRIDOR, KITCHEN_BREAK, MECHANICAL_ROOM, STORAGE, RETAIL_SALES, CLASSROOM, LAB, PATIENT_ROOM, OPERATING_ROOM, WAREHOUSE_STORAGE, LOADING_DOCK, COMMON_AREA, STAIRWELL_ELEVATOR, PARKING, GARAGE, ENTRY, FOYER, HALLWAY, OTHER",
        "`cantena/data/room_costs.py` defines `RoomTypeCost` Pydantic model with fields: room_type (RoomType), building_context (BuildingType), base_cost_per_sf (CostRange), typical_percent_of_building (float), cost_drivers (list[str]), notes (str)",
        "Seed data covers at least 10 residential room types (living room $180-250, kitchen $250-350, bathroom $300-450, bedroom $150-220, dining $170-240, utility $100-160, laundry $120-180, porch $80-130, garage $60-100, closet $100-150) and 6 office types (lobby $300-400, open office $200-280, corridor $150-200, restroom $350-500, conference $250-350, mechanical $120-180) plus school (classroom $250-350, corridor $180-220) and hospital (patient room $400-600, operating room $800-1200)",
        "`CostDataRepository` extended with `get_room_type_costs(building_type: BuildingType) -> list[RoomTypeCost]` — residential types return residential costs, commercial returns commercial, fallback to OTHER at generic rate",
        "Tests in `tests/test_room_costs.py`: office building has >= 5 room types; residential has >= 6 room types; kitchen > utility in cost; typical percentages sum to 90-110%; all room types have non-empty cost_drivers; unknown room type falls back to OTHER",
        "`mypy --strict` passes",
        "`ruff check cantena tests` passes"
      ],
      "priority": 1,
      "passes": true,
      "notes": "RoomType includes both residential and commercial room types because PRD 3.75 detects rooms on any drawing. Kitchens cost more than bedrooms due to cabinets/counters/plumbing/appliances; bathrooms due to fixtures/tile/plumbing density."
    },
    {
      "id": "US-402",
      "title": "Space program model with DetectedRoom bridge",
      "description": "As a developer, I want a SpaceProgram model that can be populated from three sources — (1) PRD 3.75 DetectedRoom polygons (highest accuracy), (2) LLM interpretation room breakdown, or (3) default distribution from BuildingModel — so that the cost engine always has a room-by-room program to price, regardless of how much geometry data is available.",
      "acceptanceCriteria": [
        "`cantena/models/space_program.py` defines `SpaceProgram` Pydantic model with: spaces (list[Space]), building_type (BuildingType), total_area_sf computed property summing all spaces",
        "`Space` model has: room_type (RoomType), name (str), area_sf (float), count (int, default 1), source (SpaceSource enum: GEOMETRY | LLM | ASSUMED | USER_OVERRIDE), confidence (Confidence)",
        "`SpaceProgram.from_detected_rooms(rooms: list[DetectedRoom], building_type: BuildingType) -> SpaceProgram` maps DetectedRoom.label to RoomType via LABEL_TO_ROOM_TYPE dict (LIVING ROOM->LIVING_ROOM, KITCHEN->KITCHEN, WC->WC, UTILITY->UTILITY, DINING->DINING, LAUNDRY->LAUNDRY, COATS->CLOSET, FRONT PORCH->PORCH, BACK PORCH->PORCH). Unlabeled/unmapped labels => RoomType.OTHER. source=GEOMETRY for all.",
        "`SpaceProgram.from_llm_interpretation(interp: LlmInterpretation, total_area_sf: float, building_type: BuildingType) -> SpaceProgram` maps LlmRoomInterpretation.room_type_enum to RoomType, source=LLM",
        "`SpaceProgram.from_building_model(model: BuildingModel) -> SpaceProgram` distributes gross SF across room types using typical_percent_of_building from room cost data, source=ASSUMED",
        "`SpaceProgram.update_space(index, area_sf=None, room_type=None, name=None)` changes source to USER_OVERRIDE on the affected Space",
        "Tests in `tests/test_space_program.py`: from_detected_rooms with 3 labeled rooms produces 3 Spaces with GEOMETRY source; maps 'LIVING ROOM'->LIVING_ROOM, 'WC'->WC, 'COATS'->CLOSET; from_building_model generates reasonable residential distribution; from_llm_interpretation maps LLM room types correctly; total_area_sf sums correctly; update_space changes source to USER_OVERRIDE; unlabeled DetectedRoom maps to OTHER",
        "`mypy --strict` passes",
        "`ruff check cantena tests` passes"
      ],
      "priority": 2,
      "passes": true,
      "notes": "This is the bridge between PRD 3.75 (DetectedRoom polygons) and room pricing. The mapping handles label variance (e.g., 'WC' vs 'BATHROOM', 'COATS' as closet). SpaceSource has four values: GEOMETRY, LLM, ASSUMED, USER_OVERRIDE. Depends on US-401 for RoomType enum."
    },
    {
      "id": "US-403",
      "title": "Room-type-aware cost engine",
      "description": "As a developer, I want the CostEngine to optionally accept a SpaceProgram and price each room type separately so estimates reflect cost variation across spaces.",
      "acceptanceCriteria": [
        "`CostEngine.estimate` accepts optional `space_program: SpaceProgram | None` parameter",
        "When space_program is provided: each Space priced using its room-type-specific $/SF from RoomTypeCost data; location factor and complexity multipliers still apply per-room; total cost is sum of room costs; CSI division breakdown computed by weighted average of room-type breakdowns; if room type has no specific cost data (OTHER/unmapped), fall back to whole-building $/SF",
        "When space_program is None: existing whole-building behavior preserved unchanged",
        "`CostEstimate` extended with `space_breakdown: list[SpaceCost] | None`",
        "`SpaceCost` model in estimate.py with fields: room_type (str), name (str), area_sf (float), cost_per_sf (CostRange), total_cost (CostRange), percent_of_total (float), source (str: 'geometry'|'llm'|'assumed'|'user_override')",
        "Tests in `tests/test_engine_rooms.py`: residential SpaceProgram kitchen priced higher per SF than utility; office lobby most expensive vs open office/corridor; sum of space_breakdown costs matches total_cost within 1%; without SpaceProgram existing behavior unchanged; RoomType.OTHER falls back to whole-building rate; SpaceCost.source populated correctly from Space.source",
        "`mypy --strict` passes",
        "`ruff check cantena tests` passes"
      ],
      "priority": 3,
      "passes": true,
      "notes": "SpaceCost includes a source field so frontend can show where each room came from. Unmapped rooms must not break pricing. Depends on US-401 (room cost data) and US-402 (SpaceProgram model)."
    },
    {
      "id": "US-404",
      "title": "SpaceProgram assembly: merge geometry rooms with LLM enrichment",
      "description": "As a developer, I want a service that assembles the best possible SpaceProgram by merging geometry-detected rooms with LLM interpretation, filling gaps and resolving conflicts.",
      "acceptanceCriteria": [
        "`cantena/services/space_assembler.py` defines `SpaceAssembler` class",
        "`SpaceAssembler.assemble(page_measurements: PageMeasurements, building_model: BuildingModel) -> SpaceProgram` uses priority: (1) if page_measurements.rooms exists and has labeled rooms use SpaceProgram.from_detected_rooms(), (2) else if page_measurements.llm_interpretation has room data use SpaceProgram.from_llm_interpretation(), (3) else fallback SpaceProgram.from_building_model()",
        "When using from_detected_rooms, also consult llm_interpretation to: re-classify unlabeled rooms, add missing rooms (LLM-only spaces if geometry missed them), flag anomalies (e.g., WC far too large)",
        "`SpaceAssembler.reconcile_areas(program: SpaceProgram, expected_total_sf: float) -> SpaceProgram` — if detected room sum differs from expected total, add an Unaccounted Space of type OTHER for the gap; rooms are not scaled, gap is explicit",
        "Tests in `tests/test_space_assembler.py`: geometry rooms available uses from_detected_rooms; no geometry but LLM available uses from_llm_interpretation; neither available uses from_building_model; unlabeled geometry rooms get LLM-suggested labels; area gap creates Unaccounted space; anomaly flagging for oversized WC",
        "`mypy --strict` passes",
        "`ruff check cantena tests` passes"
      ],
      "priority": 4,
      "passes": true,
      "notes": "Assembly layer: geometry-first, LLM fills gaps/flags issues, assumed distribution is last resort. The area-gap policy avoids silently 'making the numbers match.' Depends on US-402 (SpaceProgram) and US-403 (CostEngine room awareness)."
    },
    {
      "id": "US-405",
      "title": "Full enhanced pipeline: geometry rooms + LLM enrichment + room-type costing",
      "description": "As a developer, I want the full pipeline to chain geometry room detection → LLM interpretation → SpaceProgram assembly → room-type-aware cost engine so that /api/analyze produces per-room estimates from actual drawing measurements.",
      "acceptanceCriteria": [
        "`AnalysisPipeline` updated to use enhanced flow when PRD 3.75 components are available: (1) process PDF to images, (2) extract geometry with room polygons and labels, (3) run LLM interpretation if API key available, (4) assemble SpaceProgram via SpaceAssembler, (5) run CostEngine with SpaceProgram, (6) return enhanced PipelineResult",
        "`PipelineResult` extended with: space_program (SpaceProgram | None), space_breakdown (list[SpaceCost] | None), room_detection_method (str: 'polygonize' | 'llm_only' | 'assumed' | None)",
        "`/api/analyze` response includes space_breakdown when available (name, type, area, cost/SF, total cost, percent, source)",
        "Backward compatible: scanned PDF/no geometry → VLM-only + assumed SpaceProgram; geometry but no LLM key → geometry rooms + label matching only; full system → geometry + LLM enrichment + room-type costing",
        "Tests in `tests/test_enhanced_pipeline.py`: enhanced flow with mocks returns SpaceProgram with room_detection_method='polygonize'; fallback without geometry returns room_detection_method='assumed'; API response includes space_breakdown; space costs sum to total_cost; backward compatible pipeline without SpaceAssembler still works",
        "`mypy --strict` passes",
        "`ruff check cantena tests` passes"
      ],
      "priority": 5,
      "passes": false,
      "notes": "Geometry finds rooms; AI adds semantics; pricing uses room types. room_detection_method communicates trust level to the user/UI. Depends on US-404 (SpaceAssembler)."
    },
    {
      "id": "US-406",
      "title": "Backend: POST /api/estimate with SpaceProgram support",
      "description": "As a developer, I want the POST /api/estimate endpoint to accept an optional SpaceProgram JSON body so the frontend can send user-edited room programs for recalculation.",
      "acceptanceCriteria": [
        "`POST /api/estimate` accepts optional `space_program` field in request body as SpaceProgram JSON",
        "When space_program is provided, CostEngine uses room-type-aware pricing and returns space_breakdown in response",
        "When space_program is omitted, existing behavior preserved (whole-building estimate)",
        "Response schema updated to include space_breakdown array when available",
        "Tests: /api/estimate with SpaceProgram body returns room-type-aware estimate with space_breakdown; without SpaceProgram body returns standard estimate",
        "`mypy --strict` passes",
        "`ruff check cantena tests` passes"
      ],
      "priority": 6,
      "passes": false,
      "notes": "Split from original US-406. This is the backend endpoint needed before the frontend can send recalculation requests. Depends on US-403 (room-type-aware engine)."
    },
    {
      "id": "US-407",
      "title": "Frontend: space breakdown display table",
      "description": "As a PM reviewing an estimate, I want to see cost broken down by room type with clear source indicators so I can understand how each space contributes to the total cost.",
      "acceptanceCriteria": [
        "Results UI updated: new 'Space Program' section between building parameters and CSI division breakdown",
        "Space Program table columns: room name, room type, area (SF), cost/SF (range), total cost, percent of total — sorted by cost descending",
        "Source indicators per row: tape-measure icon for GEOMETRY, brain icon for LLM, dashed-circle icon for ASSUMED, pencil icon for USER_OVERRIDE — with tooltip explaining source",
        "If no rooms detected (space_breakdown null), Space Program section shows fallback message + assumed distribution table",
        "TypeScript types updated in lib/types.ts to include SpaceCost and space_breakdown in AnalyzeResponse",
        "`npm run typecheck` passes",
        "`npm run lint` passes",
        "Verify in browser using dev-browser skill"
      ],
      "priority": 7,
      "passes": false,
      "notes": "Split from original US-406. The key UX trust signal is the GEOMETRY ('tape-measure') indicator: it means measured from the drawing, not guessed. Depends on US-405 (pipeline returns space_breakdown) and US-406 (estimate endpoint)."
    },
    {
      "id": "US-408",
      "title": "Frontend: room-level editing and recalculation",
      "description": "As a PM reviewing an estimate, I want to adjust room areas and types and recalculate so I can validate and refine the AI-detected space program.",
      "acceptanceCriteria": [
        "Room area editable via number input in each row of the Space Program table",
        "Room type changeable via dropdown populated from RoomType enum values",
        "Users can add new rooms (row with empty fields) and remove existing rooms (delete button per row)",
        "Editing any room changes its source indicator to USER_OVERRIDE (pencil icon)",
        "'Recalculate' button sends updated SpaceProgram + BuildingModel to POST /api/estimate and refreshes the estimate display",
        "`npm run typecheck` passes",
        "`npm run lint` passes",
        "Verify in browser using dev-browser skill"
      ],
      "priority": 8,
      "passes": false,
      "notes": "Split from original US-406. This adds interactivity on top of the display table from US-407. Depends on US-406 (estimate endpoint accepts SpaceProgram) and US-407 (display table exists)."
    }
  ]
}
